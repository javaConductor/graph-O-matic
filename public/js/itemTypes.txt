Builtin Item Types

Person{ category:'People', firstName, lastName, photos(IMAGE)[], birthdate, sex, email[], address(StreetAddress), comments }
Male{parent:Person, sex:male}
Female{parent:Person, sex:female}
Business{name, mainAddress(StreetAddress), branches[](StreetAddress), mainIndustry, }
StreetAddress{ address, address2, city, state, postalCode, country }

Track{category:Audio, title, artist(Person|Artist), producer(Person|Artist|Producer), audioClip(Audio), audioFile(Audio), credits(TrackCredits) }
Artist{category:Audio, name, photos[]{Image), groupMembers[](GroupMember)}
GroupMember{category:Audio, parent: Person, contribution}
TrackCredits{category:Audio, track, contribution, contribution(Person|Artist|GroupMember)}
Recording{category:Audio, title, label(RecordLabel), execProducer(Person), credits(TrackCredits), images[](Image), media, format}
VinylRecording{parent:Recording, media:Vinyl}
DigitalRecording{parent:Recording, media:digital }
CDRecording{parent:DigitalRecording, format:CD}
MP3Recording{parent:DigitalRecording, format:mp3}
WAVRecording{parent:DigitalRecording, format:wav}
MP4aRecording{parent:DigitalRecording, format:mp4a}
WMARecording{parent:DigitalRecording, format:wma}
MediaFile{mimeType, fileURL}
Audio{parent:MediaFile, mimeType:{mp3,wav,mp4a,wma}}
Image{parent:MediaFile, mimeType:{gif,jpg,png,bmp}}
RecordLabel{parent:Business,industry:Music }


designations: these are implied attributes
    examples: parent = hasRelationship(item, Child) and IsType(item, Person)
        married = hasRelationship(item, Spouse) and IsType(item, Person)
        twentyYearClub = hasDesignation(married) and (relationship(item, Spouse)).Date.year - Now().year) => 20

optimization:
    read the into list of lists where the first is the one we want and the rest are parents - that way we don't
    have to traverse but once or at intervals.
    line them up like this:
        WMARecording,DigitalRecording,Recording
        DigitalRecording,Recording
        Recording
        RecordLabel,Business
        Business
        Audio, MediaFile
        Image, MediaFile

    Better yet, lets create a map {thing, list(hierarchy of thing - specific to generic)}



======================================================================
use case 1:
======================================================================

check to see if an item has a Sibling relationship to another item.

get all outgoing relationships 
foreach relationship rel
	if rel.is(Si) return true;


-----------------------------------------------
relationship.is(rel){
	return isOneOf(getHierarchy(rel));
}

relationship.isOneOf(relList){
	relList.any(function(rel){
		return this.id = rel.id;
	});

}

======================================================================
use case 2:
======================================================================
validate an item for relationship constraints
Relationship{name:writerOf, constraint:[item.isInTypes([Person,Writer])]
check to see if an item is of type Person.
function foo(relationship
get all items in view 
items.foreach (function(item){
	relationship
})
	if rel.is(Si) return true;


-----------------------------------------------
relationship.is(rel){
	return isOneOf(getHierarchy(rel));
}

relationship.isOneOf(relList){
	relList.any(function(rel){
		return this.id = rel.id;
	});

}


======================================================================
use case 3: Load the view
======================================================================
Get all items in a view and all relationships between these views.


1 - get list of items
	get the static list
	then if view has dynamic criteria then do a full scan of all items against the view criteria

2- find all relationship where the 'from' is in the items AND the 'to' is in the items.

At this point the view is loaded!



======================================================================
use case 4: Determine possible relationships between two items
======================================================================


								
======================================================================
Relationship Details
======================================================================
Type Definition examples:

RelationshipType{category:Literature,
	name:writerOf, 
	constraintFrom:[item.isInTypes([Person,Writer])], 
	constraintTo:[item.isInTypes([LiteraryWork])]
}

produces:

Relationship{
	type:writerOf, from:123, to:456
}

where 'to' is:

Item{type:Person,
	id:123,
	data:{firstname:'',lastname:''}
}

and 'from' is:

Item{type:Person,
	id:123,
	data:{firstname:'',lastname:''}
}


RelationshipType{category:Professional,
	name:worksFor, 
	dated:true,//relationships have sets of start and end dates.
	constraintFrom:[item.isInTypes([Person])], 
	constraintTo:[item.isInTypes([Business])]
}
