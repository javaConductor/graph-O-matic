Builtin Item Types

Person{ category:'People', firstName, lastName, photos(IMAGE)[], birthdate, sex, email[], address(StreetAddress), comments }
Male{parent:Person, sex:male}
Female{parent:Person, sex:female}
Business{name, mainAddress(StreetAddress), branches[](StreetAddress), mainIndustry, }
StreetAddress{ address, address2, city, state, postalCode, country }

Track{category:Audio, title, artist(Person|Artist), producer(Person|Artist|Producer), audioClip(Audio), audioFile(Audio), credits(TrackCredits) }
Artist{category:Audio, name, photos[]{Image), groupMembers[](GroupMember)}
GroupMember{category:Audio, parent: Person, contribution}
TrackCredits{category:Audio, track, contribution, contribution(Person|Artist|GroupMember)}
Recording{category:Audio, title, label(RecordLabel), execProducer(Person), credits(TrackCredits), images[](Image), media, format}
VinylRecording{parent:Recording, media:Vinyl}
DigitalRecording{parent:Recording, media:digital }
CDRecording{parent:DigitalRecording, format:CD}
MP3Recording{parent:DigitalRecording, format:mp3}
WAVRecording{parent:DigitalRecording, format:wav}
MP4aRecording{parent:DigitalRecording, format:mp4a}
WMARecording{parent:DigitalRecording, format:wma}
MediaFile{mimeType, fileURL}
Audio{parent:MediaFile, mimeType:{mp3,wav,mp4a,wma}}
Image{parent:MediaFile, mimeType:{gif,jpg,png,bmp}}
RecordLabel{parent:Business,industry:Music }


designations: these are implied attributes
    examples: parent = hasRelationship(item, Child) and IsType(item, Person)
        married = hasRelationship(item, Spouse) and IsType(item, Person)
        twentyYearClub = hasDesignation(married) and (relationship(item, Spouse)).Date.year - Now().year) => 20

optimization:
    read the into list of lists where the first is the one we want and the rest are parents - that way we don't
    have to traverse but once or at intervals.
    line them up like this:
        WMARecording,DigitalRecording,Recording
        DigitalRecording,Recording
        Recording
        RecordLabel,Business
        Business
        Audio, MediaFile
        Image, MediaFile

    Better yet, lets create a map {thing, list(hierarchy of thing - specific to generic)}


use case 1:

check to see if an item has a Sibling relationship to another item.

get all outgoing relationships 
foreach relationship rel
	if rel.is(Si) return true;


-----------------------------------------------
relationship.is(rel){
	return isOneOf(getHierarchy(rel));
}

relationship.isOneOf(relList){
	relList.any(function(rel){
		return this.id = rel.id;
	});

}


use case 2:
validate an item for relationship constraints
Relationship{name:writerOf, constraint:[item.isInTypes([Person,Writer])]
check to see if an item is of type Person.
function foo(relationship
get all items in view 
items.foreach (function(item){
	relationship
})
	if rel.is(Si) return true;


-----------------------------------------------
relationship.is(rel){
	return isOneOf(getHierarchy(rel));
}

relationship.isOneOf(relList){
	relList.any(function(rel){
		return this.id = rel.id;
	});

}

