Builtin Item Types

Person{ category:'People', firstName, lastName, photos(IMAGE)[], birthdate, sex, email[], address(StreetAddress), comments }
Male{parent:Person, sex:male}
Female{parent:Person, sex:female}
Business{name, mainAddress(StreetAddress), branches[](StreetAddress), mainIndustry, }
StreetAddress{ address, address2, city, state, postalCode, country }

Track{category:Audio, title, artist(Person|Artist), producer(Person|Artist|Producer), audioClip(Audio), audioFile(Audio), credits(TrackCredits) }
Artist{category:Audio, name, photos[]{Image), groupMembers[](GroupMember)}
GroupMember{category:Audio, parent: Person, contribution}
TrackCredits{category:Audio, track, contribution, contribution(Person|Artist|GroupMember)}
Recording{category:Audio, title, label(RecordLabel), execProducer(Person), credits(TrackCredits), images[](Image), media, format}
VinylRecording{parent:Recording, media:Vinyl}
DigitalRecording{parent:Recording, media:digital }
CDRecording{parent:DigitalRecording, format:CD}
MP3Recording{parent:DigitalRecording, format:mp3}
WAVRecording{parent:DigitalRecording, format:wav}
MP4aRecording{parent:DigitalRecording, format:mp4a}
WMARecording{parent:DigitalRecording, format:wma}
MediaFile{mimeType, fileURL}
Audio{parent:MediaFile, mimeType:{mp3,wav,mp4a,wma}}
Image{parent:MediaFile, mimeType:{gif,jpg,png,bmp}}
RecordLabel{parent:Business,industry:Music }


designations: these are implied attributes
    examples: parent = hasRelationship(item, Child) and IsType(item, Person)
        married = hasRelationship(item, Spouse) and IsType(item, Person)
        twentyYearClub = hasDesignation(married) and (relationship(item, Spouse)).Date.year - Now().year) => 20

optimization:
    read the into list of lists where the first is the one we want and the rest are parents - that way we don't
    have to traverse but once or at intervals.
    line them up like this:
        WMARecording,DigitalRecording,Recording
        DigitalRecording,Recording
        Recording
        RecordLabel,Business
        Business
        Audio, MediaFile
        Image, MediaFile

    Better yet, lets create a map {thing, list(hierarchy of thing - specific to generic)}



======================================================================
use case 1:
======================================================================

check to see if an item has a Sibling relationship to another item.

get all outgoing relationships 
foreach relationship rel
	if rel.is(Si) return true;


-----------------------------------------------
relationship.is(rel){
	return isOneOf(getHierarchy(rel));
}

relationship.isOneOf(relList){
	relList.any(function(rel){
		return this.id = rel.id;
	});

}

======================================================================
use case 2:
======================================================================
validate an item for relationship constraints
Relationship{name:writerOf, constraint:[item.isInTypes([Person,Writer])]
check to see if an item is of type Person.
function foo(relationship
get all items in view 
items.foreach (function(item){
	relationship
})
	if rel.is(Si) return true;


-----------------------------------------------
relationship.is(rel){
	return isOneOf(getHierarchy(rel));
}

relationship.isOneOf(relList){
	relList.any(function(rel){
		return this.id = rel.id;
	});

}


======================================================================
use case 3: Load the view
======================================================================
Get all items in a view and all relationships between these views.


1 - get list of items
	get the static list
	then if view has dynamic criteria then do a full scan of all items against the view criteria

2- find all relationship where the 'from' is in the items AND the 'to' is in the items.

At this point the view is loaded!



======================================================================
use case 4: Determine possible relationships between two items
======================================================================


								
======================================================================
Relationship Details
======================================================================
Type Definition examples:

RelationshipType{category:Literature,
	name:writerOf, 
	constraintFrom:[item.isInTypes([Person,Writer])], 
	constraintTo:[item.isInTypes([LiteraryWork])]
}

produces:

Relationship{
	type:writerOf, from:123, to:456
}

where 'to' is:

Item{type:Person,
	id:123,
	data:{firstname:'',lastname:''}
}

and 'from' is:

Item{type:Book,
	id:456,
	data:{title:'Moby Dick'}
}


RelationshipType{category:Professional,
	name:worksFor, 
	dated:true,//relationships have sets of start and end dates.
	constraintFrom:[item.isInTypes([Person])], 
	constraintTo:[item.isInTypes([Business])]
}

produces:

Relationship{
	type:worksFor, 
	from:123, to:456, 
	duration:{
		currentStart:20130430T120000, 
		previous:[
			[20100330T120000,20110330T120000],
			[20120330T120000,20130330T120000]
		]
	},
	notes: [ {date:"20130330", note: ""}, ... ]
}

where 'from' is:

Item{type:Person,
	id:123,
	data:{firstname:'',lastname:''}
}

where 'to' is:

Item{type:Business,
	id:456,
	data:{name:'IBM'}
}
				
======================================================================
Item Details
======================================================================

ItemType :
{
	name:"Person",
	category: "People",
	requiredData:[
		{name: firstName, type: text},
	],
	optionalData:[
		{name: lastName, type: text},
		{name: birthdate, relationshipType: 'hasBirthdate', itemType:"CalendarDate"},
		{name: deathDate, relationshipType: 'diedOn', itemType:"CalendarDate"},
		{name: family,  relationshipType: 'relatedTo', itemType:"Person"},
		{name: residence, relationshipType: 'resides', itemTypes:["StreetAddress","City","State","Country"]},
	]
}

yields:

Item{
	type:"Person",
	id: "132",
	data:{
		firstName: "Lee",
		birthdate: 
	}
}

Relationship{
	type:"hasBirthdate",
	id: "777",
	from:"132",
	to: "456"
}

Item{
	type:"CalendarDate",
	id: "456",
	data:{date: ""}
}
	
